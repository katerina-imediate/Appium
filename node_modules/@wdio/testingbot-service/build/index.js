// src/launcher.ts
import { performance, PerformanceObserver } from "node:perf_hooks";
import { promisify } from "node:util";
import testingbotTunnel from "testingbot-tunnel-launcher";
import logger from "@wdio/logger";
var log = logger("@wdio/testingbot-service");
var TestingBotLauncher = class {
  options;
  tbTunnelOpts;
  tunnel;
  constructor(options) {
    this.options = options;
  }
  async onPrepare(config, capabilities) {
    if (!this.options.tbTunnel || !config.user || !config.key) {
      return;
    }
    const tbTunnelIdentifier = this.options.tbTunnelOpts?.tunnelIdentifier || `TB-tunnel-${Math.random().toString().slice(2)}`;
    this.tbTunnelOpts = Object.assign({
      apiKey: config.user,
      apiSecret: config.key,
      "tunnel-identifier": tbTunnelIdentifier
    }, this.options.tbTunnelOpts);
    const capabilitiesEntries = Array.isArray(capabilities) ? capabilities.every((cap) => Object.values(cap).length > 0 && Object.values(cap).every((c) => typeof c === "object" && c.capabilities)) ? capabilities.flatMap((cap) => Object.values(cap)) : capabilities : Object.values(capabilities);
    for (const capability of capabilitiesEntries) {
      const caps = capability.capabilities || capability;
      const c = caps.alwaysMatch || caps;
      if (!c["tb:options"]) {
        c["tb:options"] = {};
      }
      c["tb:options"]["tunnel-identifier"] = tbTunnelIdentifier;
    }
    const obs = new PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      log.info(`TestingBot tunnel successfully started after ${entry.duration}ms`);
    });
    obs.observe({ entryTypes: ["measure"] });
    performance.mark("tbTunnelStart");
    this.tunnel = await promisify(testingbotTunnel)(this.tbTunnelOpts);
    performance.mark("tbTunnelEnd");
    performance.measure("bootTime", "tbTunnelStart", "tbTunnelEnd");
  }
  /**
   * Shut down the tunnel
   * @returns {Promise} Resolved promise when tunnel is closed
   */
  onComplete() {
    if (!this.tunnel) {
      return;
    }
    return new Promise((resolve) => this.tunnel.close(resolve));
  }
};

// src/service.ts
import logger2 from "@wdio/logger";
var log2 = logger2("@wdio/testingbot-service");
var jobDataProperties = ["name", "tags", "public", "build", "extra"];
var TestingBotService = class {
  constructor(_options, _capabilities, _config) {
    this._options = _options;
    this._capabilities = _capabilities;
    this._config = _config;
    this._tbUser = this._config.user;
    this._tbSecret = this._config.key;
    this._isServiceEnabled = Boolean(this._tbUser && this._tbSecret);
  }
  _browser;
  _isServiceEnabled;
  _suiteTitle;
  _tbSecret;
  _tbUser;
  _failures = 0;
  _testCnt = 0;
  before(caps, specs, browser) {
    this._browser = browser;
  }
  /**
   * Before suite
   * @param {object} suite Suite
  */
  beforeSuite(suite) {
    this._suiteTitle = suite.title;
  }
  /**
   * Before test
   * @param {object} test Test
  */
  beforeTest(test) {
    if (!this._isServiceEnabled || !this._browser) {
      return;
    }
    if (this._suiteTitle === "Jasmine__TopLevel__Suite") {
      this._suiteTitle = test.fullName.slice(0, test.fullName.indexOf(test.title) - 1);
    }
    const context = (
      /**
       * Jasmine
       */
      test.fullName || /**
       * Mocha
       */
      `${test.parent} - ${test.title}`
    );
    this._browser.execute("tb:test-context=" + context);
  }
  afterSuite(suite) {
    if (Object.prototype.hasOwnProperty.call(suite, "error")) {
      ++this._failures;
    }
  }
  /**
   * After test
   * @param {object} test Test
   */
  afterTest(_test, _context, results) {
    if (!results.passed) {
      ++this._failures;
    }
  }
  /**
   * For CucumberJS
   */
  /**
   * Before feature
   * @param {string} uri
   * @param {object} feature
   */
  beforeFeature(uri, feature) {
    if (!this._isServiceEnabled || !this._browser) {
      return;
    }
    this._suiteTitle = feature.name;
    this._browser.execute("tb:test-context=Feature: " + this._suiteTitle);
  }
  /**
   * Before scenario
   * @param {string} uri
   * @param {object} feature
   * @param {object} scenario
   */
  beforeScenario(world) {
    if (!this._isServiceEnabled || !this._browser) {
      return;
    }
    const scenarioName = world.pickle.name;
    this._browser.execute("tb:test-context=Scenario: " + scenarioName);
  }
  /**
   *
   * Runs before a Cucumber Scenario.
   * @param world world object containing information on pickle and test step
   * @param result result object containing
   * @param result.passed   true if scenario has passed
   * @param result.error    error stack if scenario failed
   * @param result.duration duration of scenario in milliseconds
   */
  afterScenario(world, result) {
    if (!result.passed) {
      ++this._failures;
    }
  }
  /**
   * Update TestingBot info
   * @return {Promise} Promise with result of updateJob method call
   */
  after(result) {
    if (!this._isServiceEnabled || !this._browser) {
      return;
    }
    let failures = this._failures;
    if (this._config.mochaOpts?.bail && Boolean(result)) {
      failures = 1;
    }
    const status = "status: " + (failures > 0 ? "failing" : "passing");
    if (!this._browser.isMultiremote) {
      log2.info(`Update job with sessionId ${this._browser.sessionId}, ${status}`);
      return this.updateJob(this._browser.sessionId, failures);
    }
    const browser = this._browser;
    return Promise.all(Object.keys(this._capabilities).map((browserName) => {
      log2.info(`Update multiremote job for browser "${browserName}" and sessionId ${browser.getInstance(browserName).sessionId}, ${status}`);
      return this.updateJob(browser.getInstance(browserName).sessionId, failures, false, browserName);
    }));
  }
  onReload(oldSessionId, newSessionId) {
    if (!this._isServiceEnabled || !this._browser) {
      return;
    }
    const status = "status: " + (this._failures > 0 ? "failing" : "passing");
    if (!this._browser.isMultiremote) {
      log2.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
      return this.updateJob(oldSessionId, this._failures, true);
    }
    const browser = this._browser;
    const browserName = browser.instances.filter(
      (browserName2) => browser.getInstance(browserName2).sessionId === newSessionId
    )[0];
    log2.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
    return this.updateJob(oldSessionId, this._failures, true, browserName);
  }
  async updateJob(sessionId, failures, calledOnReload = false, browserName) {
    if (!this._browser) {
      return;
    }
    let headers = {
      "Content-Type": "application/json; charset=utf-8"
    };
    if (this._tbUser && this._tbSecret) {
      const encodedAuth = Buffer.from(`${this._tbUser}:${this._tbSecret}`, "utf8").toString("base64");
      headers = {
        ...headers,
        Authorization: `Basic ${encodedAuth}`
      };
    }
    const json = this.getBody(failures, calledOnReload, browserName);
    this._failures = 0;
    const response = await fetch(this.getRestUrl(sessionId), {
      method: "PUT",
      body: JSON.stringify(json),
      headers
    });
    return await response.json();
  }
  /**
   *
   * @param   {String} sessionId Session id
   * @returns {String}           TestingBot API URL
   */
  getRestUrl(sessionId) {
    return `https://api.testingbot.com/v1/tests/${sessionId}`;
  }
  getBody(failures, calledOnReload = false, browserName) {
    const body = { test: {} };
    body.test.name = this._suiteTitle;
    if ((calledOnReload || this._testCnt) && this._browser) {
      let testCnt = ++this._testCnt;
      if (this._browser.isMultiremote) {
        testCnt = Math.ceil(testCnt / this._browser.instances.length);
      }
      body.test.name += ` (${testCnt})`;
    }
    for (const prop of jobDataProperties) {
      if (!this._capabilities[prop]) {
        continue;
      }
      body.test[prop] = this._capabilities[prop];
    }
    if (browserName) {
      body.test.name = `${browserName}: ${body.test.name}`;
    }
    body.test.success = failures === 0 ? "1" : "0";
    return body;
  }
};

// src/index.ts
var src_default = TestingBotService;
var launcher = TestingBotLauncher;
export {
  src_default as default,
  launcher
};
